<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WebGPU / WebGL Effect Gallery</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #02030a;
      --panel: #0b1024;
      --border: rgba(255, 255, 255, 0.08);
      --accent: #4cf3ff;
      --accent-2: #ff4fd8;
      --text: #eef3ff;
      --muted: #90a2c8;
      --radius: 14px;
      --shadow: 0 20px 50px rgba(0, 0, 0, 0.55);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Inter", "SF Pro Text", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(76, 243, 255, 0.08), transparent 40%),
        radial-gradient(circle at 80% 0%, rgba(255, 79, 216, 0.08), transparent 35%),
        var(--bg);
      color: var(--text);
      padding: clamp(16px, 3vw, 32px);
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: clamp(16px, 3vw, 32px);
    }

    header {
      grid-column: 1 / -1;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    h1 {
      margin: 0;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: clamp(1.2rem, 2vw, 1.6rem);
    }

    .meta {
      color: var(--muted);
      font-size: 0.95rem;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
    }

    #gallery {
      display: grid;
      gap: 12px;
    }

    .card {
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 14px;
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.0)),
        rgba(255, 255, 255, 0.01);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .card h3 { margin: 0; font-size: 1rem; }
    .card p { margin: 0; color: var(--muted); font-size: 0.95rem; }

    .tag-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .tag {
      padding: 4px 8px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 999px;
      border: 1px solid var(--border);
    }

    .btn {
      appearance: none;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 14px;
      background: linear-gradient(135deg, rgba(76, 243, 255, 0.12), rgba(255, 79, 216, 0.12));
      color: var(--text);
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.1s ease, border-color 0.15s ease;
    }

    .btn:hover { transform: translateY(-1px); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35); }
    .btn:active { transform: translateY(0); box-shadow: none; }

    #canvas-stack {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 16px;
      align-content: start;
    }

    .instance {
      position: relative;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      background: #000;
      min-height: 240px;
    }

    .instance header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      padding: 10px 12px;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.65), transparent);
      color: #fff;
      z-index: 2;
      font-size: 0.9rem;
    }

    .instance canvas { width: 100%; height: 100%; display: block; }

    .chip {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    @media (max-width: 960px) {
      body { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>WebGPU / WebGL Effect Gallery</h1>
      <div class="meta">Modular scene snippets you can launch standalone or mix on the same page.</div>
    </div>
    <button id="stop-all" class="btn" type="button">Stop All</button>
  </header>

  <section class="panel" id="left">
    <h2 style="margin-top:0">Effects</h2>
    <div id="gallery"></div>
  </section>

  <section class="panel" id="right">
    <div class="controls" style="justify-content: space-between; margin-bottom: 8px;">
      <span class="chip">Active mix (independent canvases)</span>
      <span class="chip" id="active-count">0 running</span>
    </div>
    <div id="canvas-stack"></div>
  </section>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';

    /**
     * Generic orchestrator that mounts effect instances into cards.
     */
    class EffectOrchestrator {
      constructor(container, counter) {
        this.container = container;
        this.counter = counter;
        this.instances = new Set();
        window.addEventListener('resize', () => this.resizeAll());
      }

      add(effectDef) {
        const wrapper = document.createElement('article');
        wrapper.className = 'instance';

        const header = document.createElement('header');
        const title = document.createElement('span');
        title.textContent = effectDef.name;
        const close = document.createElement('button');
        close.textContent = 'Stop';
        close.className = 'btn';
        close.style.padding = '6px 10px';
        close.style.fontSize = '0.9rem';
        header.append(title, close);

        const canvas = document.createElement('canvas');
        wrapper.append(header, canvas);
        this.container.append(wrapper);

        const effect = effectDef.factory(canvas);
        effect.start();

        const instance = { wrapper, effect };
        close.addEventListener('click', () => this.remove(instance));
        this.instances.add(instance);
        this.updateCounter();
      }

      remove(instance) {
        if (!this.instances.has(instance)) return;
        instance.effect.stop();
        instance.wrapper.remove();
        this.instances.delete(instance);
        this.updateCounter();
      }

      stopAll() {
        [...this.instances].forEach((inst) => this.remove(inst));
      }

      resizeAll() {
        this.instances.forEach(({ effect }) => effect.resize());
      }

      updateCounter() {
        this.counter.textContent = `${this.instances.size} running`;
      }
    }

    /**
     * Effect: Cyber Tunnel (extracted from demoscene_visualizer-v0_0_2.html)
     * A post-processed cylinder tunnel with a morphing totem and palette shifts.
     */
    function createCyberTunnelEffect(canvas) {
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setClearColor(0x000000, 1);

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.002);

      const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1500);
      camera.position.z = 5;

      const tunnelGeometry = new THREE.CylinderGeometry(30, 30, 1000, 32, 20, true);
      tunnelGeometry.rotateX(-Math.PI / 2);

      const vertexShader = /* glsl */`
        varying vec2 vUv;
        varying vec3 vPos;
        uniform float uTime;
        void main() {
          vUv = uv;
          vPos = position;
          vec3 pos = position;
          float twist = sin(pos.z * 0.1 + uTime * 0.5) * 5.0;
          pos.x += cos(pos.z * 0.05 + uTime) * 10.0;
          pos.y += sin(pos.z * 0.05 + uTime) * 10.0;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `;

      const fragmentShader = /* glsl */`
        varying vec2 vUv;
        varying vec3 vPos;
        uniform float uTime;
        uniform vec3 uColor1;
        uniform vec3 uColor2;
        uniform float uBeat;
        void main() {
          float gridX = step(0.95, fract(vUv.x * 20.0 + uTime * 0.2));
          float gridY = step(0.95, fract(vUv.y * 4.0));
          float lightPulse = sin(vUv.y * 20.0 - uTime * 5.0);
          lightPulse = smoothstep(0.8, 1.0, lightPulse);
          float fog = smoothstep(200.0, 50.0, abs(vPos.z));
          vec3 baseColor = mix(uColor1, uColor2, sin(vUv.x * 3.14 + uTime));
          vec3 finalColor = baseColor * (gridX + gridY * 0.5);
          finalColor += uColor2 * lightPulse * uBeat * 2.0;
          gl_FragColor = vec4(finalColor, fog);
        }
      `;

      const tunnelMaterial = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uColor1: { value: new THREE.Color(0x00ffff) },
          uColor2: { value: new THREE.Color(0xff00ff) },
          uBeat: { value: 0 },
        },
        vertexShader,
        fragmentShader,
        side: THREE.DoubleSide,
        transparent: true,
        blending: THREE.AdditiveBlending,
      });

      const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
      scene.add(tunnel);

      const totemGeo = new THREE.IcosahedronGeometry(8, 2);
      const wireframeMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.5 });
      const glowMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const totem = new THREE.Mesh(totemGeo, wireframeMat);
      const totemCore = new THREE.Mesh(new THREE.IcosahedronGeometry(6, 0), glowMat);
      totem.add(totemCore);
      totem.position.z = -100;
      scene.add(totem);

      const composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      const bloomPass = new UnrealBloomPass(new THREE.Vector2(1, 1), 1.5, 0.4, 0.85);
      bloomPass.threshold = 0;
      bloomPass.strength = 2.0;
      bloomPass.radius = 0.5;
      composer.addPass(bloomPass);

      const glitchPass = new GlitchPass();
      glitchPass.goWild = false;
      glitchPass.enabled = false;
      composer.addPass(glitchPass);

      const palettes = [
        { c1: 0x00aaff, c2: 0xff00aa },
        { c1: 0x00ff00, c2: 0xffaa00 },
        { c1: 0xff0044, c2: 0xaa00ff },
      ];
      let currentPalette = 0;

      const BPM = 128;
      const clock = new THREE.Clock();
      let running = false;

      function resize() {
        const { clientWidth, clientHeight } = canvas;
        if (clientWidth === 0 || clientHeight === 0) return;
        camera.aspect = clientWidth / clientHeight;
        camera.fov = clientHeight > clientWidth ? 90 : 75;
        camera.updateProjectionMatrix();
        renderer.setSize(clientWidth, clientHeight, false);
        composer.setSize(clientWidth, clientHeight);
      }

      function renderFrame() {
        if (!running) return;
        const time = clock.getElapsedTime();
        const beatDuration = 60 / BPM;
        const beatFrac = (time % beatDuration) / beatDuration;
        const beatHit = Math.pow(1.0 - beatFrac, 3.0);

        tunnelMaterial.uniforms.uTime.value = time;
        tunnelMaterial.uniforms.uBeat.value = beatHit;

        camera.position.z = 5 - time * 20;
        if (camera.position.z < tunnel.position.z - 500) {
          tunnel.position.z = camera.position.z - 500;
        }
        camera.position.x = Math.sin(time * 0.5) * 2 + (Math.random() - 0.5) * beatHit * 0.5;
        camera.position.y = Math.cos(time * 0.3) * 2 + (Math.random() - 0.5) * beatHit * 0.5;

        totem.position.z = camera.position.z - 80;
        totem.rotation.x += 0.01;
        totem.rotation.y += 0.02 + beatHit * 0.1;
        totem.scale.setScalar(1 + beatHit * 0.3);

        const phase = Math.floor(time / 20) % palettes.length;
        if (phase !== currentPalette) {
          currentPalette = phase;
          glitchPass.enabled = true;
          setTimeout(() => (glitchPass.enabled = false), 400);
        }

        const col1 = new THREE.Color(palettes[currentPalette].c1);
        const col2 = new THREE.Color(palettes[currentPalette].c2);
        const mixCol = col1.clone().lerp(col2, Math.sin(time) * 0.5 + 0.5);
        totemCore.material.color = mixCol;
        totem.material.color = col2;
        tunnelMaterial.uniforms.uColor1.value.lerp(col1, 0.02);
        tunnelMaterial.uniforms.uColor2.value.lerp(col2, 0.02);

        composer.render();
      }

      function dispose() {
        renderer.setAnimationLoop(null);
        tunnelGeometry.dispose();
        tunnelMaterial.dispose();
        totemGeo.dispose();
        wireframeMat.dispose();
        glowMat.dispose();
        composer.dispose();
        renderer.dispose();
      }

      return {
        name: 'Cyber Tunnel',
        start() {
          if (running) return;
          running = true;
          clock.start();
          resize();
          renderer.setAnimationLoop(renderFrame);
        },
        stop() {
          running = false;
          dispose();
        },
        resize,
      };
    }

    /**
     * Effect: CYBERNOID Deep Dive (extracted from demoscene_visualizer-v0_0_3.html)
     * Three morphing holograms inside a warped tunnel with palette changes and glitch pulses.
     */
    function createCybernoidDeepDiveEffect(canvas) {
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setClearColor(0x000000, 1);

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.0015);

      const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 2000);
      camera.position.z = 20;

      const tunnelGeometry = new THREE.CylinderGeometry(50, 50, 1500, 64, 40, true);
      tunnelGeometry.rotateX(-Math.PI / 2);

      const tunnelVertex = /* glsl */ `
        varying vec2 vUv;
        varying vec3 vPos;
        uniform float uTime;

        void main() {
          vUv = uv;
          vPos = position;
          vec3 pos = position;
          float twist = sin(pos.z * 0.05 + uTime * 0.2) * 20.0;
          pos.x += cos(pos.z * 0.02 + uTime * 0.5) * 15.0 + twist;
          pos.y += sin(pos.z * 0.03 + uTime * 0.3) * 15.0 + twist;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `;

      const tunnelFragment = /* glsl */ `
        varying vec2 vUv;
        varying vec3 vPos;
        uniform float uTime;
        uniform vec3 uColor1;
        uniform vec3 uColor2;
        uniform float uBeat;

        void main() {
          float gridX = step(0.97, fract(vUv.x * 24.0 + uTime * 0.1));
          float gridY = step(0.97, fract(vUv.y * 4.0));

          float lightPulse = sin(vUv.y * 10.0 - uTime * 8.0);
          lightPulse = smoothstep(0.9, 1.0, lightPulse);

          float fog = smoothstep(400.0, 50.0, abs(vPos.z));

          vec3 baseColor = mix(uColor1, uColor2, sin(vUv.x * 3.14 + uTime));
          vec3 finalColor = baseColor * (gridX + gridY * 0.5);
          finalColor += uColor2 * lightPulse * uBeat * 3.0;

          gl_FragColor = vec4(finalColor, fog);
        }
      `;

      const holoVertex = /* glsl */ `
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vPos;
        uniform float uTime;
        uniform float uDisplace;

        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 = v - i + dot(i, C.xxx) ;
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute( permute( permute(
                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
            float n_ = 0.142857142857;
            vec3  ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
        }

        void main() {
          vUv = uv;
          vNormal = normal;

          float noiseVal = snoise(position * 0.1 + uTime * 0.5);
          vec3 newPos = position + normal * (noiseVal * uDisplace * 5.0);

          if (uDisplace > 0.8) {
              newPos.x += snoise(vec3(uTime * 10.0, position.y, position.z)) * 2.0;
          }

          vPos = newPos;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
        }
      `;

      const holoFragment = /* glsl */ `
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vPos;
        uniform float uTime;
        uniform vec3 uColor;
        uniform float uOpacity;

        void main() {
          float scan = sin(vPos.y * 2.0 - uTime * 5.0) * 0.5 + 0.5;
          float scanLine = step(0.5, scan);

          vec3 viewDir = vec3(0.0, 0.0, 1.0);
          float rim = 1.0 - abs(dot(vNormal, viewDir));
          rim = pow(rim, 3.0);

          float grid = step(0.9, fract(vUv.x * 20.0)) + step(0.9, fract(vUv.y * 20.0));

          vec3 finalColor = uColor * (rim + grid * 0.5 + scanLine * 0.2);

          gl_FragColor = vec4(finalColor, uOpacity * (0.3 + rim));
        }
      `;

      const tunnelMaterial = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uColor1: { value: new THREE.Color(0x00ffff) },
          uColor2: { value: new THREE.Color(0xff00ff) },
          uBeat: { value: 0 },
        },
        vertexShader: tunnelVertex,
        fragmentShader: tunnelFragment,
        side: THREE.DoubleSide,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });

      const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
      scene.add(tunnel);

      const holoMaterial = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uColor: { value: new THREE.Color(0xffffff) },
          uOpacity: { value: 0 },
          uDisplace: { value: 0 },
        },
        vertexShader: holoVertex,
        fragmentShader: holoFragment,
        transparent: true,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
      });

      const shape1 = new THREE.Mesh(new THREE.TorusKnotGeometry(12, 3, 200, 32), holoMaterial.clone());
      const shape2 = new THREE.Mesh(new THREE.IcosahedronGeometry(18, 3), holoMaterial.clone());
      const shape3 = new THREE.Mesh(new THREE.BoxGeometry(25, 25, 25, 20, 20, 20), holoMaterial.clone());
      const shapes = [shape1, shape2, shape3];

      shapes.forEach((s) => {
        s.position.z = -30;
        s.scale.setScalar(0.001);
        scene.add(s);
      });

      shape1.scale.setScalar(1);
      shape1.material.uniforms.uOpacity.value = 1;

      const composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      const bloomPass = new UnrealBloomPass(new THREE.Vector2(1, 1), 1.8, 0.4, 0.85);
      bloomPass.threshold = 0;
      bloomPass.strength = 1.8;
      bloomPass.radius = 0.8;
      composer.addPass(bloomPass);

      const glitchPass = new GlitchPass();
      glitchPass.goWild = false;
      glitchPass.enabled = false;
      composer.addPass(glitchPass);

      let glitchTimeoutId = null;

      const palettes = [
        { c1: 0x00aaff, c2: 0xff00aa },
        { c1: 0x00ff00, c2: 0xffaa00 },
        { c1: 0xff0044, c2: 0xaa00ff },
      ];

      const BPM = 128;
      const DURATION_SECONDS = 180;
      let currentTime = 0;
      let running = false;
      const clock = new THREE.Clock();

      let pointerX = 0;
      let pointerY = 0;

      const nextPhaseColor = new THREE.Color();
      const tunnelColor1 = new THREE.Color();
      const tunnelColor2 = new THREE.Color();

      function resize() {
        const { clientWidth, clientHeight } = canvas;
        if (clientWidth === 0 || clientHeight === 0) return;
        camera.aspect = clientWidth / clientHeight;
        camera.fov = clientHeight > clientWidth ? 90 : 70;
        camera.updateProjectionMatrix();
        renderer.setSize(clientWidth, clientHeight, false);
        composer.setSize(clientWidth, clientHeight);
      }

      function onPointerMove(e) {
        const rect = canvas.getBoundingClientRect();
        pointerX = (e.clientX - rect.left) / rect.width * 2 - 1;
        pointerY = (e.clientY - rect.top) / rect.height * 2 - 1;
      }

      function onPointerDown(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const pct = Math.max(0, Math.min(1, x / rect.width));
        currentTime = pct * DURATION_SECONDS;
        glitchPass.enabled = true;
        if (glitchTimeoutId) clearTimeout(glitchTimeoutId);
        glitchTimeoutId = setTimeout(() => {
          glitchPass.enabled = false;
          glitchTimeoutId = null;
        }, 200);
      }

      function renderFrame() {
        if (!running) return;

        const dt = clock.getDelta();
        currentTime += dt;
        if (currentTime >= DURATION_SECONDS) currentTime = 0;

        const totalProgress = currentTime / DURATION_SECONDS;
        const beatDuration = 60 / BPM;
        const beatFrac = (currentTime % beatDuration) / beatDuration;
        const beatHit = Math.pow(1.0 - beatFrac, 3.0);

        const phaseDuration = 30;
        const currentPhase = Math.floor(currentTime / phaseDuration) % 3;
        const nextPhase = (currentPhase + 1) % 3;
        const phaseProgress = (currentTime % phaseDuration) / phaseDuration;
        const transitionStart = 0.85;

        shapes.forEach((s, i) => {
          s.rotation.x += 0.005 + beatHit * 0.01;
          s.rotation.y += 0.01 + beatHit * 0.01;
          s.rotation.x += (pointerY * 0.5 - s.rotation.x) * 0.05;
          s.rotation.y += (pointerX * 0.5 - s.rotation.y) * 0.05;

          s.material.uniforms.uColor.value.set(palettes[currentPhase].c2);
          nextPhaseColor.set(palettes[nextPhase].c1);
          s.material.uniforms.uColor.value.lerp(
            nextPhaseColor,
            phaseProgress > 0.5 ? (phaseProgress - 0.5) * 2 : 0,
          );
          s.material.uniforms.uTime.value = currentTime;
        });

        if (phaseProgress > transitionStart) {
          const transitionFactor = (phaseProgress - transitionStart) / (1.0 - transitionStart);
          shapes[currentPhase].scale.setScalar(1.0 + transitionFactor * 2.0);
          shapes[currentPhase].material.uniforms.uOpacity.value = 1.0 - transitionFactor;
          shapes[currentPhase].material.uniforms.uDisplace.value = transitionFactor;

          shapes[nextPhase].scale.setScalar(0.1 + transitionFactor * 0.9);
          shapes[nextPhase].material.uniforms.uOpacity.value = transitionFactor;
          shapes[nextPhase].material.uniforms.uDisplace.value = 1.0 - transitionFactor;
        } else {
          shapes.forEach((s, i) => {
            if (i === currentPhase) {
              s.scale.setScalar(1.0 + beatHit * 0.05);
              s.material.uniforms.uOpacity.value = 1.0;
              s.material.uniforms.uDisplace.value = 0.0;
            } else {
              s.scale.setScalar(0.001);
              s.material.uniforms.uOpacity.value = 0.0;
            }
          });
        }

        tunnelMaterial.uniforms.uTime.value = currentTime;
        tunnelMaterial.uniforms.uBeat.value = beatHit;
        const p1 = palettes[currentPhase];
        tunnelColor1.set(p1.c1);
        tunnelColor2.set(p1.c2);
        tunnelMaterial.uniforms.uColor1.value.lerp(tunnelColor1, 0.05);
        tunnelMaterial.uniforms.uColor2.value.lerp(tunnelColor2, 0.05);

        camera.position.z = 20 - totalProgress * 30 * (DURATION_SECONDS / phaseDuration);
        if (camera.position.z < tunnel.position.z - 500) {
          tunnel.position.z = camera.position.z - 500;
        }

        shapes.forEach((s) => {
          s.position.z = camera.position.z - 40;
        });

        composer.render();
      }

      function dispose() {
        renderer.setAnimationLoop(null);
        if (glitchTimeoutId) {
          clearTimeout(glitchTimeoutId);
          glitchTimeoutId = null;
        }
        tunnelGeometry.dispose();
        tunnelMaterial.dispose();
        shapes.forEach((s) => {
          s.geometry.dispose();
          s.material.dispose();
        });
        if (composer.renderTarget1) composer.renderTarget1.dispose();
        if (composer.renderTarget2) composer.renderTarget2.dispose();
        if (bloomPass.dispose) bloomPass.dispose();
        if (glitchPass.dispose) glitchPass.dispose();
        renderer.dispose();
        canvas.removeEventListener('pointermove', onPointerMove);
        canvas.removeEventListener('pointerdown', onPointerDown);
      }

      return {
        name: 'CYBERNOID Deep Dive',
        start() {
          if (running) return;
          running = true;
          clock.start();
          resize();
          canvas.addEventListener('pointermove', onPointerMove);
          canvas.addEventListener('pointerdown', onPointerDown);
          renderer.setAnimationLoop(renderFrame);
        },
        stop() {
          running = false;
          dispose();
        },
        resize,
      };
    }

    /**
     * Effect: Prismatic Nebula
     * Swarming particles orbit crystalline shards inside a color-shifting fog.
     */
    function createPrismaticNebulaEffect(canvas) {
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setClearColor(0x000000, 1);

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x02030a, 0.0025);

      const camera = new THREE.PerspectiveCamera(70, 1, 0.1, 1000);
      camera.position.set(0, 5, 45);

      const palettes = [
        { c1: 0x4cf3ff, c2: 0xff4fd8 },
        { c1: 0xffc857, c2: 0x4ade80 },
        { c1: 0xa78bfa, c2: 0x5eead4 },
      ];
      let paletteIndex = 0;

      const starsGeometry = new THREE.BufferGeometry();
      const starCount = 1500;
      const positions = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++) {
        const i3 = i * 3;
        const radius = Math.random() * 120 + 20;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);
        positions[i3] = Math.sin(phi) * Math.cos(theta) * radius;
        positions[i3 + 1] = Math.sin(phi) * Math.sin(theta) * radius;
        positions[i3 + 2] = Math.cos(phi) * radius;
      }
      starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const starsMaterial = new THREE.PointsMaterial({ color: palettes[0].c1, size: 0.6, transparent: true, opacity: 0.8 });
      const stars = new THREE.Points(starsGeometry, starsMaterial);
      scene.add(stars);

      const shardGeo = new THREE.IcosahedronGeometry(6, 1);
      const shardMat = new THREE.MeshStandardMaterial({
        color: palettes[0].c2,
        metalness: 0.8,
        roughness: 0.15,
        transparent: true,
        opacity: 0.9,
        emissive: new THREE.Color(0x111111),
        emissiveIntensity: 0.8,
      });

      const shardCount = 14;
      const shards = [];
      for (let i = 0; i < shardCount; i++) {
        const shard = new THREE.Mesh(shardGeo.clone(), shardMat.clone());
        shard.position.set((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20);
        shard.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        shard.scale.setScalar(0.6 + Math.random() * 1.8);
        scene.add(shard);
        shards.push(shard);
      }

      const ambient = new THREE.AmbientLight(0x404040, 1.2);
      const rimLight = new THREE.PointLight(palettes[0].c2, 20, 200);
      rimLight.position.set(0, 15, 30);
      scene.add(ambient, rimLight);

      const composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      const bloomPass = new UnrealBloomPass(new THREE.Vector2(1, 1), 1.1, 0.4, 0.85);
      bloomPass.threshold = 0.1;
      bloomPass.strength = 1.6;
      bloomPass.radius = 0.6;
      composer.addPass(bloomPass);

      const clock = new THREE.Clock();
      let running = false;

      function resize() {
        const { clientWidth, clientHeight } = canvas;
        if (clientWidth === 0 || clientHeight === 0) return;
        camera.aspect = clientWidth / clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(clientWidth, clientHeight, false);
        composer.setSize(clientWidth, clientHeight);
      }

      function renderFrame() {
        if (!running) return;
        const elapsed = clock.getElapsedTime();

        stars.rotation.y = elapsed * 0.02;
        stars.rotation.x = Math.sin(elapsed * 0.1) * 0.1;

        shards.forEach((shard, i) => {
          shard.rotation.x += 0.005 + i * 0.0005;
          shard.rotation.y += 0.006 + i * 0.0004;
          shard.position.x = Math.sin(elapsed * 0.2 + i) * 12;
          shard.position.y = Math.cos(elapsed * 0.15 + i * 0.7) * 10;
        });

        const phase = Math.floor(elapsed / 12) % palettes.length;
        if (phase !== paletteIndex) {
          paletteIndex = phase;
        }
        const nextPalette = palettes[(paletteIndex + 1) % palettes.length];
        const blend = Math.min(1, (elapsed % 12) / 4);

        rimLight.color.lerpColors(new THREE.Color(palettes[paletteIndex].c2), new THREE.Color(nextPalette.c2), blend);
        starsMaterial.color.lerpColors(new THREE.Color(palettes[paletteIndex].c1), new THREE.Color(nextPalette.c1), blend);
        shards.forEach((shard) => {
          shard.material.color.lerpColors(new THREE.Color(palettes[paletteIndex].c2), new THREE.Color(nextPalette.c2), blend);
          shard.material.emissive.lerpColors(new THREE.Color(0x111111), new THREE.Color(palettes[paletteIndex].c2), 0.5);
        });

        camera.position.x = Math.sin(elapsed * 0.15) * 10;
        camera.position.y = 6 + Math.sin(elapsed * 0.25) * 2;
        camera.lookAt(0, 0, 0);

        composer.render();
      }

      function dispose() {
        renderer.setAnimationLoop(null);
        starsGeometry.dispose();
        starsMaterial.dispose();
        shards.forEach((shard) => {
          shard.geometry.dispose();
          shard.material.dispose();
        });
        composer.dispose();
        renderer.dispose();
      }

      return {
        name: 'Prismatic Nebula',
        start() {
          if (running) return;
          running = true;
          clock.start();
          resize();
          renderer.setAnimationLoop(renderFrame);
        },
        stop() {
          running = false;
          dispose();
        },
        resize,
      };
    }

    const effects = [
      {
        id: 'cyber-tunnel',
        name: 'Cyber Tunnel',
        description: 'Warping grid tunnel with bloom, glitch hits, and a rotating totem lifted from the demoscene visualizer.',
        tags: ['WebGL', 'PostFX', 'Procedural'],
        factory: createCyberTunnelEffect,
      },
      {
        id: 'cybernoid-deep-dive',
        name: 'CYBERNOID: Deep Dive',
        description: 'Three morphing holograms pulse inside a warped tunnel with glitchable scrubbing and palette swaps.',
        tags: ['WebGL', 'Shaders', 'Demoscene'],
        factory: createCybernoidDeepDiveEffect,
      },
      {
        id: 'prismatic-nebula',
        name: 'Prismatic Nebula',
        description: 'Shifting shards and stardust swirling through a kaleidoscopic nebula.',
        tags: ['WebGL', 'Particles', 'Bloom'],
        factory: createPrismaticNebulaEffect,
      },
    ];

    const gallery = document.getElementById('gallery');
    const stack = document.getElementById('canvas-stack');
    const counter = document.getElementById('active-count');
    const orchestrator = new EffectOrchestrator(stack, counter);

    effects.forEach((effect) => {
      const card = document.createElement('article');
      card.className = 'card';
      const title = document.createElement('h3');
      title.textContent = effect.name;
      const desc = document.createElement('p');
      desc.textContent = effect.description;
      const tags = document.createElement('div');
      tags.className = 'tag-row';
      effect.tags.forEach((t) => {
        const chip = document.createElement('span');
        chip.className = 'tag';
        chip.textContent = t;
        tags.append(chip);
      });

      const button = document.createElement('button');
      button.className = 'btn';
      button.type = 'button';
      button.textContent = 'Launch in mix';
      button.addEventListener('click', () => orchestrator.add(effect));

      card.append(title, desc, tags, button);
      gallery.append(card);
    });

    document.getElementById('stop-all').addEventListener('click', () => orchestrator.stopAll());
  </script>
</body>
</html>
