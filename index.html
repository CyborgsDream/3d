<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WebGPU / WebGL Effect Gallery</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #02030a;
      --panel: #0b1024;
      --border: rgba(255, 255, 255, 0.08);
      --accent: #4cf3ff;
      --accent-2: #ff4fd8;
      --text: #eef3ff;
      --muted: #90a2c8;
      --radius: 14px;
      --shadow: 0 20px 50px rgba(0, 0, 0, 0.55);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Inter", "SF Pro Text", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(76, 243, 255, 0.08), transparent 40%),
        radial-gradient(circle at 80% 0%, rgba(255, 79, 216, 0.08), transparent 35%),
        var(--bg);
      color: var(--text);
      padding: clamp(16px, 3vw, 32px);
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: clamp(16px, 3vw, 32px);
    }

    header {
      grid-column: 1 / -1;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    h1 {
      margin: 0;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: clamp(1.2rem, 2vw, 1.6rem);
    }

    .meta {
      color: var(--muted);
      font-size: 0.95rem;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
    }

    #primary-panel {
      grid-column: 1 / -1;
      display: grid;
      grid-template-columns: minmax(280px, 360px) 1fr;
      gap: 16px;
      align-items: start;
    }

    #primary-meta h2 {
      margin: 0 0 4px 0;
    }

    #primary-meta p {
      margin: 0;
      color: var(--muted);
    }

    .player-controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    #primary-stage {
      position: relative;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      background: #000;
      min-height: 320px;
      box-shadow: var(--shadow);
    }

    .stage-action {
      position: absolute;
      z-index: 4;
      top: 12px;
      right: 12px;
      padding: 8px 12px;
    }

    #primary-canvas {
      width: 100%;
      height: 100%;
      display: block;
      aspect-ratio: 16 / 9;
    }

    .primary-overlay {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 12px 14px;
      background: linear-gradient(180deg, transparent, rgba(0, 0, 0, 0.7));
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #fff;
      pointer-events: none;
    }

    #primary-title {
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .timeline-row {
      margin-top: 12px;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
    }

    #timeline {
      width: 100%;
    }

    #time-readout {
      color: var(--muted);
      font-size: 0.95rem;
      text-align: right;
    }

    .muted {
      color: var(--muted);
    }

    #gallery {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    .card {
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 12px;
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.0)),
        rgba(255, 255, 255, 0.01);
      display: grid;
      gap: 10px;
    }

    .card h3 { margin: 0; font-size: 1rem; }

    .thumb {
      position: relative;
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      background: #000;
      aspect-ratio: 16 / 9;
      box-shadow: var(--shadow);
    }

    .thumb canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .tag-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .tag {
      padding: 4px 8px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 999px;
      border: 1px solid var(--border);
    }

    .btn {
      appearance: none;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 14px;
      background: linear-gradient(135deg, rgba(76, 243, 255, 0.12), rgba(255, 79, 216, 0.12));
      color: var(--text);
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.1s ease, border-color 0.15s ease;
    }

    .btn:hover { transform: translateY(-1px); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35); }
    .btn:active { transform: translateY(0); box-shadow: none; }

    #canvas-stack {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 16px;
      align-content: start;
    }

    .instance {
      position: relative;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      background: #000;
      min-height: 240px;
    }

    .instance header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      padding: 10px 12px;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.65), transparent);
      color: #fff;
      z-index: 2;
      font-size: 0.9rem;
    }

    .instance canvas { width: 100%; height: 100%; display: block; }

    .chip {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    @media (max-width: 960px) {
      body { grid-template-columns: 1fr; }
      #primary-panel {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>WebGPU / WebGL Effect Gallery</h1>
      <div class="meta">Modular scene snippets you can launch standalone or mix on the same page.</div>
    </div>
    <button id="stop-all" class="btn" type="button">Stop All</button>
  </header>

  <section class="panel" id="primary-panel">
    <div id="primary-meta">
      <div class="chip">Primary canvas</div>
      <h2>Effect spotlight</h2>
      <p>Browse every effect on a dedicated canvas with scrubbable timeline controls.</p>
      <div class="player-controls">
        <button class="btn" id="prev-effect" type="button">Previous</button>
        <button class="btn" id="next-effect" type="button">Next</button>
      </div>
      <div class="timeline-row">
        <input type="range" id="timeline" min="0" max="1" step="0.001" value="0" />
        <div id="time-readout">0:00 / 0:00</div>
      </div>
    </div>
    <div id="primary-stage">
      <button id="fullscreen-toggle" class="btn stage-action" type="button">Enter Fullscreen</button>
      <canvas id="primary-canvas"></canvas>
      <div class="primary-overlay">
        <span id="primary-title">â€”</span>
        <span class="chip">Scrub or jump to any moment</span>
      </div>
    </div>
  </section>

  <section class="panel" id="left">
    <h2 style="margin-top:0">Effects</h2>
    <div id="gallery"></div>
  </section>

  <section class="panel" id="right">
    <div class="controls" style="justify-content: space-between; margin-bottom: 8px;">
      <span class="chip">Active mix (independent canvases)</span>
      <span class="chip" id="active-count">0 running</span>
    </div>
    <div id="canvas-stack"></div>
  </section>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';

    /**
     * Generic orchestrator that mounts effect instances into cards.
     */
    class EffectOrchestrator {
      constructor(container, counter) {
        this.container = container;
        this.counter = counter;
        this.instances = new Set();
        window.addEventListener('resize', () => this.resizeAll());
      }

      add(effectDef) {
        const wrapper = document.createElement('article');
        wrapper.className = 'instance';

        const header = document.createElement('header');
        const title = document.createElement('span');
        title.textContent = effectDef.name;
        const close = document.createElement('button');
        close.textContent = 'Stop';
        close.className = 'btn';
        close.style.padding = '6px 10px';
        close.style.fontSize = '0.9rem';
        header.append(title, close);

        const canvas = document.createElement('canvas');
        wrapper.append(header, canvas);
        this.container.append(wrapper);

        const effect = effectDef.factory(canvas);
        effect.start();

        const instance = { wrapper, effect };
        close.addEventListener('click', () => this.remove(instance));
        this.instances.add(instance);
        this.updateCounter();
      }

      remove(instance) {
        if (!this.instances.has(instance)) return;
        instance.effect.stop();
        instance.wrapper.remove();
        this.instances.delete(instance);
        this.updateCounter();
      }

      stopAll() {
        [...this.instances].forEach((inst) => this.remove(inst));
      }

      resizeAll() {
        this.instances.forEach(({ effect }) => effect.resize());
      }

      updateCounter() {
        this.counter.textContent = `${this.instances.size} running`;
      }
    }

    /**
     * Dedicated player for the spotlight canvas.
     * It supports previous/next navigation and timeline scrubbing when the effect exposes hooks.
     */
    class EffectPlayer {
      constructor({ canvas, titleEl, timeline, readout, effects, onIndexChange }) {
        this.canvas = canvas;
        this.titleEl = titleEl;
        this.timeline = timeline;
        this.readout = readout;
        this.effects = effects;
        this.onIndexChange = onIndexChange;
        this.currentIndex = 0;
        this.currentInstance = null;
        this.animFrame = null;

        this.timeline.addEventListener('input', (e) => this.seek(Number(e.target.value)));
        window.addEventListener('resize', () => this.resize());
      }

      load(index) {
        const normalized = ((index % this.effects.length) + this.effects.length) % this.effects.length;
        this.currentIndex = normalized;
        const def = this.effects[normalized];
        this.stop();
        this.titleEl.textContent = def.name;
        this.currentInstance = def.factory(this.canvas);
        this.currentInstance.start();
        this.timeline.disabled = typeof this.currentInstance.seek !== 'function';
        if (typeof this.onIndexChange === 'function') this.onIndexChange(normalized);
        this.tick();
        this.resize();
      }

      formatTime(progress, duration) {
        const totalSeconds = Math.max(0, Math.round(progress * duration));
        const minutes = Math.floor(totalSeconds / 60).toString();
        const seconds = (totalSeconds % 60).toString().padStart(2, '0');
        const totalMinutes = Math.floor(duration / 60).toString();
        const totalSecondsPart = Math.round(duration % 60).toString().padStart(2, '0');
        return `${minutes}:${seconds} / ${totalMinutes}:${totalSecondsPart}`;
      }

      tick() {
        cancelAnimationFrame(this.animFrame);
        const step = () => {
          if (this.currentInstance && typeof this.currentInstance.getProgress === 'function') {
            const progress = Math.min(Math.max(this.currentInstance.getProgress(), 0), 1);
            this.timeline.value = progress;
            const duration = this.currentInstance.duration || 180;
            this.readout.textContent = this.formatTime(progress, duration);
          }
          this.animFrame = requestAnimationFrame(step);
        };
        this.animFrame = requestAnimationFrame(step);
      }

      seek(progress) {
        if (!this.currentInstance || typeof this.currentInstance.seek !== 'function') return;
        const clamped = Math.min(Math.max(progress, 0), 1);
        this.currentInstance.seek(clamped);
      }

      next() {
        this.load(this.currentIndex + 1);
      }

      prev() {
        this.load(this.currentIndex - 1);
      }

      resize() {
        if (this.currentInstance && typeof this.currentInstance.resize === 'function') {
          this.currentInstance.resize();
        }
      }

      stop() {
        cancelAnimationFrame(this.animFrame);
        if (this.currentInstance && typeof this.currentInstance.stop === 'function') {
          this.currentInstance.stop();
        }
        this.currentInstance = null;
      }
    }

    /**
     * Effect: Cyber Tunnel (extracted from demoscene_visualizer-v0_0_2.html)
     * A post-processed cylinder tunnel with a morphing totem and palette shifts.
     */
    function createCyberTunnelEffect(canvas, options = {}) {
      const enableTunnel = options.enableTunnel !== false;
      const enableTotem = options.enableTotem !== false;
      const enableGlitch = options.enableGlitch !== false;

      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setClearColor(0x000000, 1);

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.002);

      const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1500);
      camera.position.z = 5;

      const tunnelGeometry = enableTunnel ? new THREE.CylinderGeometry(30, 30, 1000, 32, 20, true) : null;
      if (tunnelGeometry) tunnelGeometry.rotateX(-Math.PI / 2);

      const vertexShader = /* glsl */`
        varying vec2 vUv;
        varying vec3 vPos;
        uniform float uTime;
        void main() {
          vUv = uv;
          vPos = position;
          vec3 pos = position;
          float twist = sin(pos.z * 0.1 + uTime * 0.5) * 5.0;
          pos.x += cos(pos.z * 0.05 + uTime) * 10.0;
          pos.y += sin(pos.z * 0.05 + uTime) * 10.0;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `;

      const fragmentShader = /* glsl */`
        varying vec2 vUv;
        varying vec3 vPos;
        uniform float uTime;
        uniform vec3 uColor1;
        uniform vec3 uColor2;
        uniform float uBeat;
        void main() {
          float gridX = step(0.95, fract(vUv.x * 20.0 + uTime * 0.2));
          float gridY = step(0.95, fract(vUv.y * 4.0));
          float lightPulse = sin(vUv.y * 20.0 - uTime * 5.0);
          lightPulse = smoothstep(0.8, 1.0, lightPulse);
          float fog = smoothstep(200.0, 50.0, abs(vPos.z));
          vec3 baseColor = mix(uColor1, uColor2, sin(vUv.x * 3.14 + uTime));
          vec3 finalColor = baseColor * (gridX + gridY * 0.5);
          finalColor += uColor2 * lightPulse * uBeat * 2.0;
          gl_FragColor = vec4(finalColor, fog);
        }
      `;

      const tunnelMaterial = enableTunnel
        ? new THREE.ShaderMaterial({
            uniforms: {
              uTime: { value: 0 },
              uColor1: { value: new THREE.Color(0x00ffff) },
              uColor2: { value: new THREE.Color(0xff00ff) },
              uBeat: { value: 0 },
            },
            vertexShader,
            fragmentShader,
            side: THREE.DoubleSide,
            transparent: true,
            blending: THREE.AdditiveBlending,
          })
        : null;

      const tunnel = enableTunnel ? new THREE.Mesh(tunnelGeometry, tunnelMaterial) : null;
      if (tunnel) scene.add(tunnel);

      const totemGeo = enableTotem ? new THREE.IcosahedronGeometry(8, 2) : null;
      const wireframeMat = enableTotem
        ? new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.5 })
        : null;
      const glowMat = enableTotem ? new THREE.MeshBasicMaterial({ color: 0xffffff }) : null;
      const totem = enableTotem ? new THREE.Mesh(totemGeo, wireframeMat) : null;
      const totemCore = enableTotem ? new THREE.Mesh(new THREE.IcosahedronGeometry(6, 0), glowMat) : null;
      if (totem && totemCore) {
        totem.add(totemCore);
        totem.position.z = -100;
        scene.add(totem);
      }

      const composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      const bloomPass = new UnrealBloomPass(new THREE.Vector2(1, 1), 1.5, 0.4, 0.85);
      bloomPass.threshold = 0;
      bloomPass.strength = 2.0;
      bloomPass.radius = 0.5;
      composer.addPass(bloomPass);

      const glitchPass = enableGlitch ? new GlitchPass() : null;
      if (glitchPass) {
        glitchPass.goWild = false;
        glitchPass.enabled = false;
        composer.addPass(glitchPass);
      }

      const palettes = [
        { c1: 0x00aaff, c2: 0xff00aa },
        { c1: 0x00ff00, c2: 0xffaa00 },
        { c1: 0xff0044, c2: 0xaa00ff },
      ];
      let currentPalette = 0;

        const BPM = 128;
        const clock = new THREE.Clock();
        let running = false;
        let manualTime = 0;

      function resize() {
        const { clientWidth, clientHeight } = canvas;
        if (clientWidth === 0 || clientHeight === 0) return;
        camera.aspect = clientWidth / clientHeight;
        camera.fov = clientHeight > clientWidth ? 90 : 75;
        camera.updateProjectionMatrix();
        renderer.setSize(clientWidth, clientHeight, false);
        composer.setSize(clientWidth, clientHeight);
      }

      function renderFrame() {
        if (!running) return;
        const time = manualTime + clock.getElapsedTime();
        const beatDuration = 60 / BPM;
        const beatFrac = (time % beatDuration) / beatDuration;
        const beatHit = Math.pow(1.0 - beatFrac, 3.0);

        if (enableTunnel && tunnelMaterial) {
          tunnelMaterial.uniforms.uTime.value = time;
          tunnelMaterial.uniforms.uBeat.value = beatHit;

          camera.position.z = 5 - time * 20;
          if (tunnel && camera.position.z < tunnel.position.z - 500) {
            tunnel.position.z = camera.position.z - 500;
          }
          camera.position.x = Math.sin(time * 0.5) * 2 + (Math.random() - 0.5) * beatHit * 0.5;
          camera.position.y = Math.cos(time * 0.3) * 2 + (Math.random() - 0.5) * beatHit * 0.5;
        } else {
          camera.position.set(Math.sin(time * 0.3) * 6, Math.cos(time * 0.25) * 4, 18 + Math.sin(time * 0.2) * 4);
          camera.lookAt(0, 0, 0);
        }

        if (enableTotem && totem) {
          totem.position.z = enableTunnel ? camera.position.z - 80 : 0;
          totem.rotation.x += 0.01;
          totem.rotation.y += 0.02 + beatHit * 0.1;
          totem.scale.setScalar(1 + beatHit * 0.3);
        }

        const phase = Math.floor(time / 20) % palettes.length;
        if (phase !== currentPalette && glitchPass) {
          currentPalette = phase;
          glitchPass.enabled = true;
          setTimeout(() => (glitchPass.enabled = false), 400);
        } else if (phase !== currentPalette) {
          currentPalette = phase;
        }

        if (enableTotem && totemCore && totem) {
          const col1 = new THREE.Color(palettes[currentPalette].c1);
          const col2 = new THREE.Color(palettes[currentPalette].c2);
          const mixCol = col1.clone().lerp(col2, Math.sin(time) * 0.5 + 0.5);
          totemCore.material.color = mixCol;
          totem.material.color = col2;
          if (tunnelMaterial) {
            tunnelMaterial.uniforms.uColor1.value.lerp(col1, 0.02);
            tunnelMaterial.uniforms.uColor2.value.lerp(col2, 0.02);
          }
        }

        composer.render();
      }

      function dispose() {
        renderer.setAnimationLoop(null);
        if (tunnelGeometry) tunnelGeometry.dispose();
        if (tunnelMaterial) tunnelMaterial.dispose();
        if (totemGeo) totemGeo.dispose();
        if (wireframeMat) wireframeMat.dispose();
        if (glowMat) glowMat.dispose();
        if (totemCore) totemCore.geometry.dispose();
        if (totemCore && totemCore.material) totemCore.material.dispose();
        if (totem && totem.material) totem.material.dispose();
        composer.dispose();
        renderer.dispose();
      }

      return {
        name: 'Cyber Tunnel',
        start() {
          if (running) return;
          running = true;
          clock.start();
          resize();
          renderer.setAnimationLoop(renderFrame);
        },
        stop() {
          running = false;
          dispose();
        },
        resize,
        seek(progress) {
          manualTime = Math.max(progress, 0) * 120;
          clock.start();
        },
        getProgress() {
          return ((manualTime + clock.getElapsedTime()) % 120) / 120;
        },
        duration: 120,
      };
    }

    /**
     * Effect: CYBERNOID Deep Dive (extracted from demoscene_visualizer-v0_0_3.html)
     * Three morphing holograms inside a warped tunnel with palette changes and glitch pulses.
     */
    function createCybernoidDeepDiveEffect(canvas, options = {}) {
      const showTunnel = options.showTunnel !== false;
      const showHolograms = options.showHolograms !== false;
      const enableGlitch = options.enableGlitch !== false;

      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setClearColor(0x000000, 1);

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.0015);

      const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 2000);
      camera.position.z = 20;

      const tunnelGeometry = showTunnel ? new THREE.CylinderGeometry(50, 50, 1500, 64, 40, true) : null;
      if (tunnelGeometry) tunnelGeometry.rotateX(-Math.PI / 2);

      const tunnelVertex = /* glsl */ `
        varying vec2 vUv;
        varying vec3 vPos;
        uniform float uTime;

        void main() {
          vUv = uv;
          vPos = position;
          vec3 pos = position;
          float twist = sin(pos.z * 0.05 + uTime * 0.2) * 20.0;
          pos.x += cos(pos.z * 0.02 + uTime * 0.5) * 15.0 + twist;
          pos.y += sin(pos.z * 0.03 + uTime * 0.3) * 15.0 + twist;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `;

      const tunnelFragment = /* glsl */ `
        varying vec2 vUv;
        varying vec3 vPos;
        uniform float uTime;
        uniform vec3 uColor1;
        uniform vec3 uColor2;
        uniform float uBeat;

        void main() {
          float gridX = step(0.97, fract(vUv.x * 24.0 + uTime * 0.1));
          float gridY = step(0.97, fract(vUv.y * 4.0));

          float lightPulse = sin(vUv.y * 10.0 - uTime * 8.0);
          lightPulse = smoothstep(0.9, 1.0, lightPulse);

          float fog = smoothstep(400.0, 50.0, abs(vPos.z));

          vec3 baseColor = mix(uColor1, uColor2, sin(vUv.x * 3.14 + uTime));
          vec3 finalColor = baseColor * (gridX + gridY * 0.5);
          finalColor += uColor2 * lightPulse * uBeat * 3.0;

          gl_FragColor = vec4(finalColor, fog);
        }
      `;

      const holoVertex = /* glsl */ `
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vPos;
        uniform float uTime;
        uniform float uDisplace;

        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 = v - i + dot(i, C.xxx) ;
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute( permute( permute(
                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
            float n_ = 0.142857142857;
            vec3  ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
        }

        void main() {
          vUv = uv;
          vNormal = normal;

          float noiseVal = snoise(position * 0.1 + uTime * 0.5);
          vec3 newPos = position + normal * (noiseVal * uDisplace * 5.0);

          if (uDisplace > 0.8) {
              newPos.x += snoise(vec3(uTime * 10.0, position.y, position.z)) * 2.0;
          }

          vPos = newPos;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
        }
      `;

      const holoFragment = /* glsl */ `
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vPos;
        uniform float uTime;
        uniform vec3 uColor;
        uniform float uOpacity;

        void main() {
          float scan = sin(vPos.y * 2.0 - uTime * 5.0) * 0.5 + 0.5;
          float scanLine = step(0.5, scan);

          vec3 viewDir = vec3(0.0, 0.0, 1.0);
          float rim = 1.0 - abs(dot(vNormal, viewDir));
          rim = pow(rim, 3.0);

          float grid = step(0.9, fract(vUv.x * 20.0)) + step(0.9, fract(vUv.y * 20.0));

          vec3 finalColor = uColor * (rim + grid * 0.5 + scanLine * 0.2);

          gl_FragColor = vec4(finalColor, uOpacity * (0.3 + rim));
        }
      `;

      const tunnelMaterial = showTunnel
        ? new THREE.ShaderMaterial({
            uniforms: {
              uTime: { value: 0 },
              uColor1: { value: new THREE.Color(0x00ffff) },
              uColor2: { value: new THREE.Color(0xff00ff) },
              uBeat: { value: 0 },
            },
            vertexShader: tunnelVertex,
            fragmentShader: tunnelFragment,
            side: THREE.DoubleSide,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
          })
        : null;

      const tunnel = showTunnel ? new THREE.Mesh(tunnelGeometry, tunnelMaterial) : null;
      if (tunnel) scene.add(tunnel);

      const holoMaterial = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uColor: { value: new THREE.Color(0xffffff) },
          uOpacity: { value: 0 },
          uDisplace: { value: 0 },
        },
        vertexShader: holoVertex,
        fragmentShader: holoFragment,
        transparent: true,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
      });

      const shape1 = new THREE.Mesh(new THREE.TorusKnotGeometry(12, 3, 200, 32), holoMaterial.clone());
      const shape2 = new THREE.Mesh(new THREE.IcosahedronGeometry(18, 3), holoMaterial.clone());
      const shape3 = new THREE.Mesh(new THREE.BoxGeometry(25, 25, 25, 20, 20, 20), holoMaterial.clone());
      const shapes = showHolograms ? [shape1, shape2, shape3] : [];

      shapes.forEach((s) => {
        s.position.z = -30;
        s.scale.setScalar(0.001);
        scene.add(s);
      });

      if (showHolograms) {
        shape1.scale.setScalar(1);
        shape1.material.uniforms.uOpacity.value = 1;
      }

      const composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      const bloomPass = new UnrealBloomPass(new THREE.Vector2(1, 1), 1.8, 0.4, 0.85);
      bloomPass.threshold = 0;
      bloomPass.strength = 1.8;
      bloomPass.radius = 0.8;
      composer.addPass(bloomPass);

      const glitchPass = enableGlitch ? new GlitchPass() : null;
      if (glitchPass) {
        glitchPass.goWild = false;
        glitchPass.enabled = false;
        composer.addPass(glitchPass);
      }

      let glitchTimeoutId = null;

      const palettes = [
        { c1: 0x00aaff, c2: 0xff00aa },
        { c1: 0x00ff00, c2: 0xffaa00 },
        { c1: 0xff0044, c2: 0xaa00ff },
      ];

      const BPM = 128;
      const DURATION_SECONDS = 180;
      let currentTime = 0;
      let running = false;
      const clock = new THREE.Clock();

      let pointerX = 0;
      let pointerY = 0;

      const nextPhaseColor = new THREE.Color();
      const tunnelColor1 = new THREE.Color();
      const tunnelColor2 = new THREE.Color();

      function resize() {
        const { clientWidth, clientHeight } = canvas;
        if (clientWidth === 0 || clientHeight === 0) return;
        camera.aspect = clientWidth / clientHeight;
        camera.fov = clientHeight > clientWidth ? 90 : 70;
        camera.updateProjectionMatrix();
        renderer.setSize(clientWidth, clientHeight, false);
        composer.setSize(clientWidth, clientHeight);
      }

      function onPointerMove(e) {
        const rect = canvas.getBoundingClientRect();
        pointerX = (e.clientX - rect.left) / rect.width * 2 - 1;
        pointerY = (e.clientY - rect.top) / rect.height * 2 - 1;
      }

      function onPointerDown(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const pct = Math.max(0, Math.min(1, x / rect.width));
        currentTime = pct * DURATION_SECONDS;
        if (glitchPass) {
          glitchPass.enabled = true;
          if (glitchTimeoutId) clearTimeout(glitchTimeoutId);
          glitchTimeoutId = setTimeout(() => {
            glitchPass.enabled = false;
            glitchTimeoutId = null;
          }, 200);
        }
      }

      function renderFrame() {
        if (!running) return;

        const dt = clock.getDelta();
        currentTime += dt;
        if (currentTime >= DURATION_SECONDS) currentTime = 0;

        const totalProgress = currentTime / DURATION_SECONDS;
        const beatDuration = 60 / BPM;
        const beatFrac = (currentTime % beatDuration) / beatDuration;
        const beatHit = Math.pow(1.0 - beatFrac, 3.0);

        const phaseDuration = 30;
        const currentPhase = Math.floor(currentTime / phaseDuration) % 3;
        const nextPhase = (currentPhase + 1) % 3;
        const phaseProgress = (currentTime % phaseDuration) / phaseDuration;
        const transitionStart = 0.85;

        if (showHolograms) {
          shapes.forEach((s, i) => {
            s.rotation.x += 0.005 + beatHit * 0.01;
            s.rotation.y += 0.01 + beatHit * 0.01;
            s.rotation.x += (pointerY * 0.5 - s.rotation.x) * 0.05;
            s.rotation.y += (pointerX * 0.5 - s.rotation.y) * 0.05;

            s.material.uniforms.uColor.value.set(palettes[currentPhase].c2);
            nextPhaseColor.set(palettes[nextPhase].c1);
            s.material.uniforms.uColor.value.lerp(
              nextPhaseColor,
              phaseProgress > 0.5 ? (phaseProgress - 0.5) * 2 : 0,
            );
            s.material.uniforms.uTime.value = currentTime;
          });

          if (phaseProgress > transitionStart) {
            const transitionFactor = (phaseProgress - transitionStart) / (1.0 - transitionStart);
            shapes[currentPhase].scale.setScalar(1.0 + transitionFactor * 2.0);
            shapes[currentPhase].material.uniforms.uOpacity.value = 1.0 - transitionFactor;
            shapes[currentPhase].material.uniforms.uDisplace.value = transitionFactor;

            shapes[nextPhase].scale.setScalar(0.1 + transitionFactor * 0.9);
            shapes[nextPhase].material.uniforms.uOpacity.value = transitionFactor;
            shapes[nextPhase].material.uniforms.uDisplace.value = 1.0 - transitionFactor;
          } else {
            shapes.forEach((s, i) => {
              if (i === currentPhase) {
                s.scale.setScalar(1.0 + beatHit * 0.05);
                s.material.uniforms.uOpacity.value = 1.0;
                s.material.uniforms.uDisplace.value = 0.0;
              } else {
                s.scale.setScalar(0.001);
                s.material.uniforms.uOpacity.value = 0.0;
              }
            });
          }
        }

        if (showTunnel && tunnelMaterial) {
          tunnelMaterial.uniforms.uTime.value = currentTime;
          tunnelMaterial.uniforms.uBeat.value = beatHit;
          const p1 = palettes[currentPhase];
          tunnelColor1.set(p1.c1);
          tunnelColor2.set(p1.c2);
          tunnelMaterial.uniforms.uColor1.value.lerp(tunnelColor1, 0.05);
          tunnelMaterial.uniforms.uColor2.value.lerp(tunnelColor2, 0.05);
        }

        if (showTunnel) {
          camera.position.z = 20 - totalProgress * 30 * (DURATION_SECONDS / phaseDuration);
          if (tunnel && camera.position.z < tunnel.position.z - 500) {
            tunnel.position.z = camera.position.z - 500;
          }
        }

        if (showHolograms) {
          shapes.forEach((s) => {
            s.position.z = camera.position.z - 40;
          });
        } else {
          camera.position.set(Math.sin(currentTime * 0.2) * 12, Math.cos(currentTime * 0.2) * 6, 30);
          camera.lookAt(0, 0, 0);
        }

        composer.render();
      }

      function dispose() {
        renderer.setAnimationLoop(null);
        if (glitchTimeoutId) {
          clearTimeout(glitchTimeoutId);
          glitchTimeoutId = null;
        }
        if (tunnelGeometry) tunnelGeometry.dispose();
        if (tunnelMaterial) tunnelMaterial.dispose();
        shapes.forEach((s) => {
          s.geometry.dispose();
          s.material.dispose();
        });
        if (composer.renderTarget1) composer.renderTarget1.dispose();
        if (composer.renderTarget2) composer.renderTarget2.dispose();
        if (bloomPass.dispose) bloomPass.dispose();
        if (glitchPass && glitchPass.dispose) glitchPass.dispose();
        renderer.dispose();
        canvas.removeEventListener('pointermove', onPointerMove);
        canvas.removeEventListener('pointerdown', onPointerDown);
      }

      return {
        name: 'CYBERNOID Deep Dive',
        start() {
          if (running) return;
          running = true;
          clock.start();
          resize();
          if (showHolograms) {
            canvas.addEventListener('pointermove', onPointerMove);
            canvas.addEventListener('pointerdown', onPointerDown);
          }
          renderer.setAnimationLoop(renderFrame);
        },
        stop() {
          running = false;
          dispose();
        },
        resize,
        seek(progress) {
          const clamped = Math.min(Math.max(progress, 0), 1);
          currentTime = clamped * DURATION_SECONDS;
          clock.elapsedTime = 0;
        },
        getProgress() {
          return currentTime / DURATION_SECONDS;
        },
        duration: DURATION_SECONDS,
      };
    }

    /**
     * Effect: Prismatic Nebula
     * Swarming particles orbit crystalline shards inside a color-shifting fog.
     */
    function createPrismaticNebulaEffect(canvas, options = {}) {
      const showStars = options.showStars !== false;
      const showShards = options.showShards !== false;
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setClearColor(0x000000, 1);

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x02030a, 0.0025);

      const camera = new THREE.PerspectiveCamera(70, 1, 0.1, 1000);
      camera.position.set(0, 5, 45);

      const palettes = [
        { c1: 0x4cf3ff, c2: 0xff4fd8 },
        { c1: 0xffc857, c2: 0x4ade80 },
        { c1: 0xa78bfa, c2: 0x5eead4 },
      ];
      let paletteIndex = 0;

      const starsGeometry = showStars ? new THREE.BufferGeometry() : null;
      const starCount = 1500;
      let starsMaterial = null;
      let stars = null;
      if (showStars) {
        const positions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
          const i3 = i * 3;
          const radius = Math.random() * 120 + 20;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos((Math.random() * 2) - 1);
          positions[i3] = Math.sin(phi) * Math.cos(theta) * radius;
          positions[i3 + 1] = Math.sin(phi) * Math.sin(theta) * radius;
          positions[i3 + 2] = Math.cos(phi) * radius;
        }
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        starsMaterial = new THREE.PointsMaterial({ color: palettes[0].c1, size: 0.6, transparent: true, opacity: 0.8 });
        stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);
      }

      const shards = [];
      if (showShards) {
        const shardGeo = new THREE.IcosahedronGeometry(6, 1);
        const shardMat = new THREE.MeshStandardMaterial({
          color: palettes[0].c2,
          metalness: 0.8,
          roughness: 0.15,
          transparent: true,
          opacity: 0.9,
          emissive: new THREE.Color(0x111111),
          emissiveIntensity: 0.8,
        });

        const shardCount = 14;
        for (let i = 0; i < shardCount; i++) {
          const shard = new THREE.Mesh(shardGeo.clone(), shardMat.clone());
          shard.position.set((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20);
          shard.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
          shard.scale.setScalar(0.6 + Math.random() * 1.8);
          scene.add(shard);
          shards.push(shard);
        }
      }

      const ambient = new THREE.AmbientLight(0x404040, 1.2);
      const rimLight = new THREE.PointLight(palettes[0].c2, 20, 200);
      rimLight.position.set(0, 15, 30);
      scene.add(ambient, rimLight);

      const composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      const bloomPass = new UnrealBloomPass(new THREE.Vector2(1, 1), 1.1, 0.4, 0.85);
      bloomPass.threshold = 0.1;
      bloomPass.strength = 1.6;
      bloomPass.radius = 0.6;
      composer.addPass(bloomPass);

      const clock = new THREE.Clock();
      let running = false;

      function resize() {
        const { clientWidth, clientHeight } = canvas;
        if (clientWidth === 0 || clientHeight === 0) return;
        camera.aspect = clientWidth / clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(clientWidth, clientHeight, false);
        composer.setSize(clientWidth, clientHeight);
      }

      function renderFrame() {
        if (!running) return;
        const elapsed = manualTime + clock.getElapsedTime();

        if (stars) {
          stars.rotation.y = elapsed * 0.02;
          stars.rotation.x = Math.sin(elapsed * 0.1) * 0.1;
        }

        shards.forEach((shard, i) => {
          shard.rotation.x += 0.005 + i * 0.0005;
          shard.rotation.y += 0.006 + i * 0.0004;
          shard.position.x = Math.sin(elapsed * 0.2 + i) * 12;
          shard.position.y = Math.cos(elapsed * 0.15 + i * 0.7) * 10;
        });

        const phase = Math.floor(elapsed / 12) % palettes.length;
        if (phase !== paletteIndex) {
          paletteIndex = phase;
        }
        const nextPalette = palettes[(paletteIndex + 1) % palettes.length];
        const blend = Math.min(1, (elapsed % 12) / 4);

        rimLight.color.lerpColors(new THREE.Color(palettes[paletteIndex].c2), new THREE.Color(nextPalette.c2), blend);
        if (starsMaterial) {
          starsMaterial.color.lerpColors(new THREE.Color(palettes[paletteIndex].c1), new THREE.Color(nextPalette.c1), blend);
        }
        shards.forEach((shard) => {
          shard.material.color.lerpColors(new THREE.Color(palettes[paletteIndex].c2), new THREE.Color(nextPalette.c2), blend);
          shard.material.emissive.lerpColors(new THREE.Color(0x111111), new THREE.Color(palettes[paletteIndex].c2), 0.5);
        });

        camera.position.x = Math.sin(elapsed * 0.15) * 10;
        camera.position.y = 6 + Math.sin(elapsed * 0.25) * 2;
        camera.lookAt(0, 0, 0);

        composer.render();
      }

      function dispose() {
        renderer.setAnimationLoop(null);
        if (starsGeometry) starsGeometry.dispose();
        if (starsMaterial) starsMaterial.dispose();
        shards.forEach((shard) => {
          shard.geometry.dispose();
          shard.material.dispose();
        });
        composer.dispose();
        renderer.dispose();
      }

      return {
        name: 'Prismatic Nebula',
        start() {
          if (running) return;
          running = true;
          clock.start();
          resize();
          renderer.setAnimationLoop(renderFrame);
        },
        stop() {
          running = false;
          dispose();
        },
        resize,
        seek(progress) {
          manualTime = Math.max(progress, 0) * 150;
          clock.start();
        },
        getProgress() {
          return ((manualTime + clock.getElapsedTime()) % 150) / 150;
        },
        duration: 150,
      };
    }

    /**
     * Effect: Morphing Showcase
     * A curated megamix that blends the tunnel, holograms, shards, and stardust with cinematic zooms.
     */
    function createMorphingShowcaseEffect(canvas) {
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setClearColor(0x000000, 1);

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x01020a, 0.0015);

      const camera = new THREE.PerspectiveCamera(70, 1, 0.1, 3000);
      camera.position.set(0, 4, 22);

      const ambient = new THREE.AmbientLight(0x404040, 1.2);
      const mainLight = new THREE.PointLight(0x4cf3ff, 18, 400);
      mainLight.position.set(0, 10, 24);
      scene.add(ambient, mainLight);

      const tunnelGeometry = new THREE.CylinderGeometry(80, 70, 2000, 64, 64, true);
      tunnelGeometry.rotateX(-Math.PI / 2);

      const tunnelMaterial = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uColor1: { value: new THREE.Color(0x4cf3ff) },
          uColor2: { value: new THREE.Color(0xff4fd8) },
        },
        vertexShader: /* glsl */ `
          varying vec2 vUv;
          varying vec3 vPos;
          uniform float uTime;

          void main() {
            vUv = uv;
            vPos = position;
            vec3 pos = position;
            float swirl = sin(pos.z * 0.05 + uTime * 0.6) * 18.0;
            pos.x += cos(pos.z * 0.03 + uTime) * 14.0 + swirl;
            pos.y += sin(pos.z * 0.04 + uTime * 0.7) * 14.0 - swirl * 0.5;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `,
        fragmentShader: /* glsl */ `
          varying vec2 vUv;
          varying vec3 vPos;
          uniform float uTime;
          uniform vec3 uColor1;
          uniform vec3 uColor2;

          void main() {
            float gridX = step(0.98, fract(vUv.x * 28.0 + uTime * 0.1));
            float gridY = step(0.98, fract(vUv.y * 6.0));
            float pulse = sin(vUv.y * 18.0 - uTime * 7.0);
            float fog = smoothstep(600.0, 40.0, abs(vPos.z));
            vec3 base = mix(uColor1, uColor2, sin(vUv.x * 3.1415 + uTime));
            vec3 finalColor = base * (gridX + gridY * 0.8) + base * pulse * 0.4;
            gl_FragColor = vec4(finalColor, fog);
          }
        `,
        side: THREE.DoubleSide,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });

      const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
      scene.add(tunnel);

      const starGeometry = new THREE.BufferGeometry();
      const starCount = 2200;
      const starPositions = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++) {
        const i3 = i * 3;
        const radius = Math.random() * 260 + 60;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);
        starPositions[i3] = Math.sin(phi) * Math.cos(theta) * radius;
        starPositions[i3 + 1] = Math.sin(phi) * Math.sin(theta) * radius;
        starPositions[i3 + 2] = Math.cos(phi) * radius;
      }
      starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
      const starMaterial = new THREE.PointsMaterial({ color: 0x6de3ff, size: 0.8, transparent: true, opacity: 0.7 });
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);

      const holoMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.5,
        roughness: 0.1,
        transparent: true,
        opacity: 0.0,
        emissive: new THREE.Color(0x0a0f1c),
        emissiveIntensity: 1.6,
      });

      const shapes = [
        new THREE.Mesh(new THREE.TorusKnotGeometry(18, 4, 240, 32), holoMaterial.clone()),
        new THREE.Mesh(new THREE.IcosahedronGeometry(16, 2), holoMaterial.clone()),
        new THREE.Mesh(new THREE.BoxGeometry(28, 28, 28, 24, 24, 24), holoMaterial.clone()),
        new THREE.Mesh(new THREE.OctahedronGeometry(20, 3), holoMaterial.clone()),
      ];

      shapes.forEach((shape, i) => {
        shape.position.set(0, 0, -30 - i * 2);
        shape.scale.setScalar(0.5 + i * 0.1);
        scene.add(shape);
      });

      const palettes = [
        { color: 0x4cf3ff, secondary: 0xff4fd8 },
        { color: 0xf97316, secondary: 0x67e8f9 },
        { color: 0xa78bfa, secondary: 0x22c55e },
      ];

      const composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      const bloomPass = new UnrealBloomPass(new THREE.Vector2(1, 1), 1.4, 0.35, 0.82);
      bloomPass.threshold = 0.1;
      bloomPass.strength = 1.8;
      bloomPass.radius = 0.7;
      composer.addPass(bloomPass);

      let running = false;
      let manualTime = 0;
      const clock = new THREE.Clock();
      const TOTAL_DURATION = 48;
      const PHASE_DURATION = TOTAL_DURATION / shapes.length;

      function smoothStep(t) {
        return t * t * (3 - 2 * t);
      }

      function resize() {
        const { clientWidth, clientHeight } = canvas;
        if (clientWidth === 0 || clientHeight === 0) return;
        camera.aspect = clientWidth / clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(clientWidth, clientHeight, false);
        composer.setSize(clientWidth, clientHeight);
      }

      function renderFrame() {
        if (!running) return;
        const elapsed = manualTime + clock.getElapsedTime();
        tunnelMaterial.uniforms.uTime.value = elapsed;

        const phaseIndex = Math.floor((elapsed % TOTAL_DURATION) / PHASE_DURATION);
        const phaseProgress = ((elapsed % TOTAL_DURATION) % PHASE_DURATION) / PHASE_DURATION;
        const nextIndex = (phaseIndex + 1) % shapes.length;
        const mix = smoothStep(phaseProgress);

        const palette = palettes[phaseIndex % palettes.length];
        const nextPalette = palettes[nextIndex % palettes.length];
        const lerpColor = new THREE.Color().lerpColors(
          new THREE.Color(palette.color),
          new THREE.Color(nextPalette.color),
          mix
        );
        mainLight.color.copy(lerpColor);
        bloomPass.strength = 1.4 + Math.sin(elapsed * 2.2) * 0.3 + mix * 0.3;

        const zoomPulse = 12 + Math.sin(elapsed * 1.4) * 3 + Math.sin(phaseProgress * Math.PI) * 2;
        camera.position.z = zoomPulse;
        camera.position.y = 2 + Math.sin(elapsed * 0.6) * 0.8;
        camera.lookAt(0, 0, -40);

        shapes.forEach((shape, i) => {
          shape.visible = i === phaseIndex || i === nextIndex;
          const targetOpacity = i === phaseIndex ? 1 - mix : i === nextIndex ? mix : 0;
          const material = shape.material;
          material.opacity = THREE.MathUtils.lerp(material.opacity, targetOpacity, 0.25);
          material.emissive.setHex(i === phaseIndex ? palette.secondary : nextPalette.secondary);

          const baseScale = 1.0 + Math.sin(elapsed + i) * 0.15;
          const morphScale = i === phaseIndex ? 1 + (1 - mix) * 0.4 : i === nextIndex ? 0.6 + mix * 0.8 : 0.2;
          const finalScale = baseScale * morphScale;
          shape.scale.setScalar(finalScale);

          shape.rotation.x += 0.01 + i * 0.002;
          shape.rotation.y += 0.013 + i * 0.0015;
        });

        stars.rotation.y = elapsed * 0.06;
        stars.rotation.x = Math.sin(elapsed * 0.3) * 0.1;

        composer.render();
      }

      function dispose() {
        renderer.setAnimationLoop(null);
        starGeometry.dispose();
        starMaterial.dispose();
        shapes.forEach((shape) => {
          shape.geometry.dispose();
          shape.material.dispose();
        });
        tunnelGeometry.dispose();
        tunnelMaterial.dispose();
        composer.dispose();
        renderer.dispose();
      }

      return {
        name: 'Morphing Showcase',
        start() {
          if (running) return;
          running = true;
          clock.start();
          resize();
          renderer.setAnimationLoop(renderFrame);
        },
        stop() {
          running = false;
          dispose();
        },
        resize,
        seek(progress) {
          const clamped = Math.min(Math.max(progress, 0), 1);
          manualTime = clamped * TOTAL_DURATION;
          clock.start();
        },
        getProgress() {
          return ((manualTime + clock.getElapsedTime()) % TOTAL_DURATION) / TOTAL_DURATION;
        },
        duration: TOTAL_DURATION,
      };
    }

    const effects = [
      {
        id: 'cyber-tunnel',
        name: 'Cyber Tunnel',
        description: 'Warping grid tunnel with bloom, glitch hits, and a rotating totem lifted from the demoscene visualizer.',
        tags: ['WebGL', 'PostFX', 'Procedural'],
        factory: createCyberTunnelEffect,
      },
      {
        id: 'grid-tunnel-solo',
        name: 'Grid Tunnel (solo)',
        description: 'Just the pulsing tunnel flow without the holographic totem for layering with other scenes.',
        tags: ['WebGL', 'PostFX', 'Loop'],
        factory: (canvas) => createCyberTunnelEffect(canvas, { enableTotem: false }),
      },
      {
        id: 'totem-pulse',
        name: 'Totem Pulse',
        description: 'A standalone rotating totem with bloom-only highlights for lightweight overlays.',
        tags: ['WebGL', 'Minimal', 'Bloom'],
        factory: (canvas) => createCyberTunnelEffect(canvas, { enableTunnel: false, enableGlitch: false }),
      },
      {
        id: 'cybernoid-deep-dive',
        name: 'CYBERNOID: Deep Dive',
        description: 'Three morphing holograms pulse inside a warped tunnel with glitchable scrubbing and palette swaps.',
        tags: ['WebGL', 'Shaders', 'Demoscene'],
        factory: createCybernoidDeepDiveEffect,
      },
      {
        id: 'cybernoid-warp-tunnel',
        name: 'CYBERNOID: Warp Tunnel',
        description: 'The hypnotic CYBERNOID tunnel isolated for layering under other elements.',
        tags: ['WebGL', 'Shaders', 'Loop'],
        factory: (canvas) => createCybernoidDeepDiveEffect(canvas, { showHolograms: false }),
      },
      {
        id: 'hologram-trio',
        name: 'Hologram Trio',
        description: 'The three morphing holograms without the tunnel shell for cleaner compositing.',
        tags: ['WebGL', 'Shaders', 'Minimal'],
        factory: (canvas) => createCybernoidDeepDiveEffect(canvas, { showTunnel: false, enableGlitch: false }),
      },
      {
        id: 'prismatic-nebula',
        name: 'Prismatic Nebula',
        description: 'Shifting shards and stardust swirling through a kaleidoscopic nebula.',
        tags: ['WebGL', 'Particles', 'Bloom'],
        factory: createPrismaticNebulaEffect,
      },
      {
        id: 'stardust-drift',
        name: 'Stardust Drift',
        description: 'The sparkling Prismatic starfield on its own as a gentle looping background.',
        tags: ['WebGL', 'Particles', 'Loop'],
        factory: (canvas) => createPrismaticNebulaEffect(canvas, { showShards: false }),
      },
      {
        id: 'crystal-bloom',
        name: 'Crystal Bloom',
        description: 'Floating crystalline shards with rim lighting and palette shifts, without the surrounding dust.',
        tags: ['WebGL', 'Bloom', 'Minimal'],
        factory: (canvas) => createPrismaticNebulaEffect(canvas, { showStars: false }),
      },
      {
        id: 'morphing-showcase',
        name: 'Morphing Showcase',
        description: 'A mega-mix reel that stitches all the previous elements together with dramatic zooms and morphs.',
        tags: ['WebGL', 'Cinematic', 'Blend'],
        factory: createMorphingShowcaseEffect,
      },
    ];

    const gallery = document.getElementById('gallery');
    const stack = document.getElementById('canvas-stack');
    const counter = document.getElementById('active-count');
    const primaryStage = document.getElementById('primary-stage');
    const fullscreenBtn = document.getElementById('fullscreen-toggle');
    const orchestrator = new EffectOrchestrator(stack, counter);

    const player = new EffectPlayer({
      canvas: document.getElementById('primary-canvas'),
      titleEl: document.getElementById('primary-title'),
      timeline: document.getElementById('timeline'),
      readout: document.getElementById('time-readout'),
      effects,
    });

    document.getElementById('next-effect').addEventListener('click', () => player.next());
    document.getElementById('prev-effect').addEventListener('click', () => player.prev());
    player.load(0);

    function syncFullscreenButton() {
      const isFullscreen = document.fullscreenElement === primaryStage;
      fullscreenBtn.textContent = isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen';
    }

    fullscreenBtn.addEventListener('click', () => {
      if (document.fullscreenElement === primaryStage) {
        document.exitFullscreen();
      } else {
        primaryStage.requestFullscreen();
      }
    });

    document.addEventListener('fullscreenchange', syncFullscreenButton);
    syncFullscreenButton();

    const previewResizers = [];

    effects.forEach((effect) => {
      const card = document.createElement('article');
      card.className = 'card';

      const thumb = document.createElement('div');
      thumb.className = 'thumb';
      const previewCanvas = document.createElement('canvas');
      thumb.append(previewCanvas);

      const title = document.createElement('h3');
      title.textContent = effect.name;
      const tags = document.createElement('div');
      tags.className = 'tag-row';
      effect.tags.forEach((t) => {
        const chip = document.createElement('span');
        chip.className = 'tag';
        chip.textContent = t;
        tags.append(chip);
      });

      const button = document.createElement('button');
      button.className = 'btn';
      button.type = 'button';
      button.textContent = 'Launch in mix';
      button.addEventListener('click', () => orchestrator.add(effect));

      card.append(thumb, title, tags, button);
      gallery.append(card);

      const previewInstance = effect.factory(previewCanvas);
      if (previewInstance && typeof previewInstance.start === 'function') previewInstance.start();
      const resizePreview = () => {
        if (previewInstance && typeof previewInstance.resize === 'function') {
          previewInstance.resize();
        }
      };
      resizePreview();
      previewResizers.push(resizePreview);
    });

    window.addEventListener('resize', () => {
      previewResizers.forEach((fn) => fn());
    });

    document.getElementById('stop-all').addEventListener('click', () => orchestrator.stopAll());
  </script>
</body>
</html>
